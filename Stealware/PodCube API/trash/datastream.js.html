<!DOCTYPE html>
<html lang="en">
    <head>
        
        <script>
            (function () {
                const STORAGE_KEY = 'bodge-id-v1';
                const SIZE = 5;
                // 1. Try to load existing identity
                let identity = null;
                try {
                    identity = JSON.parse(localStorage.getItem(STORAGE_KEY));
                } catch (e) {}
                // 2. If no identity, GENESIS MODE (Random Generation)
                if (! identity) {
                    const hue = Math.floor(Math.random() * 360);
                    const grid = new Array(SIZE * SIZE).fill(null);
                    // Generate Mirrored Pattern
                    for (let x = 0; x < Math.ceil(SIZE / 2); x++) {
                        for (let y = 0; y < SIZE; y++) {
                            if (Math.random() > 0.5) {
                                const alpha = (Math.random() * 0.6 + 0.4).toFixed(2);
                                // We store: { o: opacity, c: customColor (optional) }
                                const pixel = {
                                    o: alpha
                                };
                                // Set Left
                                grid[y * SIZE + x] = pixel;
                                // Set Mirror
                                if (x < Math.floor(SIZE / 2)) {
                                    grid[y * SIZE + (SIZE - 1 - x)] = pixel;
                                }
                            }
                        }
                    }
                    identity = {
                        hue,
                        grid
                    };
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(identity));
                }
                // 3. Render SVG Define Theme Colors based on the stored Hue
                const cLight = `hsl(${
                    identity.hue
                }, 80%, 40%)`;
                const cDark = `hsl(${
                    identity.hue
                }, 80%, 70%)`;
                let rects = '';
                identity.grid.forEach((pixel, i) => {
                    if (!pixel) 
                        return;
                    
                    const x = i % SIZE;
                    const y = Math.floor(i / SIZE);
                    // If pixel has a custom color, use it. Otherwise use CSS var. We use a CSS class 'themable' to let the style block
                    // handle standard pixels
                    const fillAttr = pixel.c
                        ? `fill="${
                        pixel.c
                    }"` : `class="themable"`;
                    rects += `<rect x="${x}" y="${y}" width="1" height="1" opacity="${
                        pixel.o
                    }" ${fillAttr} />`;
                });
                const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${SIZE} ${SIZE}" shape-rendering="crispEdges">
            <style>
                .themable { fill: ${cLight}; }
                @media (prefers-color-scheme: dark) {
                    .themable { fill: ${cDark}; } 
                }
                /* Custom text color checks */
                text { fill: black; font-weight: 900; pointer-events: none; }
                @media (prefers-color-scheme: dark) { text { fill: white; } }
            </style>
            ${rects}
            <text x="2.5" y="3.5" text-anchor="middle" font-family="monospace" font-size="3px"></text>
            </svg>`;
                const link = document.createElement('link');
                link.rel = 'icon';
                link.id = 'dynamic-favicon'; // ID for easier updates later
                link.href = 'data:image/svg+xml,' + encodeURIComponent(svg);
                document.head.appendChild(link);
                // Expose for the editor to use
                window.BodgeIdentity = {
                    data: identity,
                    save: (newData) => {
                        localStorage.setItem(STORAGE_KEY, JSON.stringify(newData));
                    }
                };
            })();
        </script>
        <link rel="stylesheet" href="/css/main.css">
        <script src="/js/theme.js"></script>
        <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
        <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <meta charset="UTF-8">
        <title>datastream.js</title>
        
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="generator" content="Eleventy v3.1.2">
        <meta name="description" content="A curious folder on the internet. Home of Mason Amadeus">
        <link
        rel="canonical" href="https://bodgelab.com/%7B%7B%20media.url%20|%20safe%20%7D%7D.html"> 
        <meta property="og:site_name" content="The Bodge Lab">
        <meta property="og:type" content="website">
        <meta property="og:url" content="https://bodgelab.com/%7B%7B%20media.url%20|%20safe%20%7D%7D.html">
        <meta property="og:title" content="datastream.js">
        <meta
        property="og:description" content="A curious folder on the internet. Home of Mason Amadeus"> 
        <meta property="og:image" content="https://bodgelab.com/.config/ogimg.jpg">
        <meta
        name="twitter:image" content="https://bodgelab.com/.config/ogimg.jpg">
        
        
            
            <meta name="twitter:card" content="summary_large_image">
        
    </head>
    <body>
        <svg id="paperfilter">
            <defs>
                <filter id="paperlike" x="-20%" y="-20%" width="140%" height="140%" type="fractalNoise">
                    <feTurbulence basefrequency="0.0005" numoctaves="1" result="noise"/>
                    <feDisplacementMap in="SourceGraphic" in2="noise" scale="1" xchannelselector="R" ychannelselector="R"></filter>
                </defs>
            </svg>
            <header class="sticky">
                <nav class="nav-container">
                    <div class="breadcrumb-nav">
                        <div class="breadcrumb-mover">
                            <button id="theme-toggle" class="theme-toggle" aria-label="Toggle Theme">
                                <svg
                                    viewbox="0 0 24 24"
                                    fill="none"
                                    stroke="currentColor"
                                    stroke-width="2"
                                    stroke-linecap="round"
                                    stroke-linejoin="round"
                                    class="theme-icon">
                                    <path id="sun-icon" d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                                    <g id="moon-icon">
                                        <path d="M12 2a7 7 0 0 0-7 7c0 2.32 1.04 4.39 2.66 5.82a2 2 0 0 1 .68 1.48V19a2 2 0 0 0 2 2h3.32a2 2 0 0 0 2-2v-2.7a2 2 0 0 1
                                            .68-1.48C17.96 13.39 19 11.32 19 9a7 7 0 0 0-7-7Z"></path>
                                        <path d="M9 21h6"></path>
                                        <path d="M9 17h6"></path>
                                    </g>
                                </svg>
                            </button>
                            <span class="separator">\\</span>
                            <a href="/" class="breadcrumb" title="Home Directory">BodgeLab</a>
                            
                            
                            
                                
                            
                                
                                    
                                    <span class="separator">\</span>
                                    
                                        <a href="/Stealware/" class="breadcrumb">Stealware</a>
                                    
                                
                            
                                
                                    
                                    <span class="separator">\</span>
                                    
                                        <a href="/Stealware/PodCube API/" class="breadcrumb">PodCube API</a>
                                    
                                
                            
                                
                                    
                                    <span class="separator">\</span>
                                    
                                        <a href="/Stealware/PodCube API/trash/" class="breadcrumb">trash</a>
                                    
                                
                            
                                
                                    
                                    <span class="separator">\</span>
                                    
                                        <span class="current">datastream.js</span>
                                    
                                
                            
                        </div>
                    </div>
                    <div
                        class="page-nav">
                        
                        
                            <div>
                                <a href="/Stealware/PodCube API/trash/" class="nav-link up">⇱ Go Up</a>
                            </div>
                        
                        
                        
                            <div class="page-meta-date">
                                <i>
                                    <em>Modified: February 28, 2026</em>
                                </i>
                            </div>
                        
                    </div>
                </nav>
            </header>
            
                <main class="main-content">
                    
  <h2>datastream.js</h2>
  
  
  
    <div class="media-embed-wrapper text-embed">
                      <pre class="language-js"><code class="language-js">//
// =============================================================================
// SECTOR 7: DATA STREAM (Refactored Logic)
// =============================================================================

const TILE = 7;
const UI_HEIGHT = 40;

// TERRAIN TYPES
const T_NULL = 0;      // Empty
const T_DATA = 1;      // Diggable (Blue)
const T_HARD = 2;      // Indestructible (White)
const T_CODE_R = 3;    // Ramp R
const T_CODE_L = 4;    // Ramp L
const T_FIREWALL = 5;  // Kill (Orange)
const T_PACKET = 6;    // Bonus Bits (Orange Pickup)

const MAX_FALL = 75;

// PALETTE (High Contrast Cyberspace)
const COL_BG     = &#039;#0a1929&#039;; 
const COL_DATA   = &#039;#334e68&#039;; 
const COL_HARD   = &#039;#f0f4f8&#039;; 
const COL_FIRE   = &#039;#ff6d00&#039;; 
const COL_CODE   = &#039;#4fc3f7&#039;; 
const COL_BIT    = &#039;#ffffff&#039;; 
const COL_BIT_ACTIVE = &#039;#ffd700&#039;; 
const COL_PACKET = &#039;#ff9100&#039;; 

// =============================================================================
// ENTITIES
// =============================================================================

class Fragment extends Entity {
    constructor(x, y, color) {
        super(x, y);
        this.vx = PC.rand(-60, 60);
        this.vy = PC.rand(-60, 60);
        this.color = color;
        this.life = 0.8;
        this.z = 50; 
    }
    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.life -= dt;
        if (this.life &lt;= 0) this.destroy();
    }
    draw(gfx) {
        gfx.rect(this.x, this.y, 2, 2, this.color);
    }
}

class Bit extends Physics.Actor {
    constructor(x, y) {
        super(x, y, 6, 7); 
        this.color = COL_BIT;
        this.dir = 1; 
        this.speed = 20;
        this.job = &#039;STREAM&#039;; 
        
        this.jobTimer = 0;
        this.jobCount = 0;
        this.nukeTriggered = false;

        this.fallStartY = y;
        this.wasGrounded = false;
        this.z = 10;
        this.label = Math.random() &gt; 0.5 ? &#039;1&#039; : &#039;0&#039;;
        this.flicker = 0;
    }

    assignJob(newJob) {
        if (newJob === &#039;STREAM&#039; &amp;&amp; this.job === &#039;STREAM&#039;) {
            this.dir *= -1;
            this.vx = this.dir * this.speed;
            return;
        }
        if (this.job === newJob || this.dead) return;
        this.job = newJob;
        this.jobTimer = 0;
        this.remainderX = 0;
        this.remainderY = 0;
        
        if (newJob === &#039;PATCH&#039;) this.jobCount = 5;  
        if (newJob === &#039;BRUTE&#039;) this.jobCount = 0;  
        if (newJob === &#039;DRILL&#039;) this.jobCount = 0;  
        if (newJob === &#039;GLITCH&#039;) this.jobTimer = 3.0; 

        if ([&#039;MUTEX&#039;, &#039;PATCH&#039;, &#039;GLITCH&#039;].includes(newJob)) this.vx = 0;
        this.z = 20;
    }

    update(dt, input, game) {
        if (this.dead) return; 
        const world = game.world;

        // Visuals
        this.flicker += dt;
        if (this.flicker &gt; 0.15) {
            this.label = this.label === &#039;1&#039; ? &#039;0&#039; : &#039;1&#039;;
            this.flicker = 0;
        }

        // Environment Check
        const cx = this.x + this.w/2;
        const cy = this.y + this.h; 
        const gx = world.toGrid(cx);
        const gy = world.toGrid(cy + 1); 
        
        const floorTile = world.get(gx, gy);
        if (floorTile === T_FIREWALL) { this.corrupt(game); return; }
        
        // Pickups
        const cgx = world.toGrid(this.x + this.w/2);
        const cgy = world.toGrid(this.y + this.h/2);
        if (world.get(cgx, cgy) === T_PACKET) {
            world.set(cgx, cgy, T_NULL);
            game.collectPacket();
            game.spawnFragments(cgx*TILE, cgy*TILE, COL_PACKET);
        }

        // --- PRE-PHYSICS LOGIC ---
        if (this.nukeTriggered &amp;&amp; this.job !== &#039;GLITCH&#039;) {
            this.assignJob(&#039;GLITCH&#039;);
            this.jobTimer = Math.random(); 
        }

        switch (this.job) {
            case &#039;STREAM&#039;:
            case &#039;BUFFER&#039;:
                this.vx = this.dir * this.speed;
                // STEP UP LOGIC:
                // If we are grounded, and moving, check if we are blocked ahead but clear above.
                if (this.grounded) {
                    const nextX = this.x + (this.dir * 2); 
                    if (world.overlap(nextX, this.y, this.w, this.h)) {
                        // Wall ahead. Is it a step?
                        if (!world.overlap(nextX, this.y - TILE, this.w, this.h)) {
                            this.y -= TILE;
                            this.x += this.dir;
                        }
                    }
                }
                break;
            case &#039;MUTEX&#039;:
                this.vx = 0; 
                break;
            case &#039;BRUTE&#039;: 
                this.vx = this.dir * (this.speed * 0.4); 
                const wallX = world.toGrid(this.x + this.w/2 + (this.dir * 4));
                const wallY = world.toGrid(this.y + 4);
                const tFront = world.get(wallX, wallY);
                if (tFront === T_DATA || tFront === T_PACKET) {
                    world.set(wallX, wallY, T_NULL); 
                    game.spawnFragments(wallX*TILE, wallY*TILE, COL_DATA);
                } else if (tFront === T_HARD || tFront === T_FIREWALL) {
                    this.dir *= -1; 
                    this.assignJob(&#039;STREAM&#039;);
                } 
                break;
            case &#039;DRILL&#039;: 
                this.vx = 0;
                this.jobTimer += dt;
                if (this.jobTimer &gt; 0.15) { 
                    this.jobTimer = 0;
                    const dGx = world.toGrid(this.x + this.w/2);
                    const dGy = world.toGrid(this.y + this.h + 1);
                    const tBelow = world.get(dGx, dGy);
                    if (tBelow === T_DATA || tBelow === T_PACKET) {
                        world.set(dGx, dGy, T_NULL);
                        game.spawnFragments(dGx*TILE, dGy*TILE, COL_DATA);
                    } else if (tBelow === T_HARD || tBelow === T_FIREWALL) {
                        this.assignJob(&#039;STREAM&#039;);
                    } else if (tBelow === T_NULL) {
                        this.assignJob(&#039;STREAM&#039;); 
                    }
                }
                break;
            case &#039;PATCH&#039;: 
                this.vx = 0;
                this.jobTimer -= dt;
                if (this.jobTimer &lt;= 0) {
                    if (this.jobCount &gt; 0) {
                        if (this.compileCode(world)) {
                            this.jobCount--;
                            this.jobTimer = 0.5;
                        } else {
                            this.dir *= -1;
                            this.assignJob(&#039;STREAM&#039;);
                        }
                    } else {
                        this.assignJob(&#039;STREAM&#039;);
                    }
                }
                break;
            case &#039;GLITCH&#039;: 
                this.vx = 0;
                this.jobTimer -= dt;
                if (this.jobTimer &lt;= 0) this.triggerGlitch(game);
                break;
        }

        // --- PHYSICS ---
        const wasMoving = this.vx !== 0;
        this.wasGrounded = this.grounded;
        
        if (this.job === &#039;BUFFER&#039; &amp;&amp; this.vy &gt; 20) {
            this.vy = 20; 
            this.fallStartY = this.y; 
        }

        this.updatePhysics(dt, world, 600);

        // --- POST-PHYSICS LOGIC ---
        // If we wanted to move but Physics stopped us (vx became 0), we hit a wall.
        if (wasMoving &amp;&amp; this.vx === 0) {
            this.dir *= -1; // Flip
            this.vx = this.dir * this.speed; // Visual feedback
        }

        if (this.grounded &amp;&amp; !this.wasGrounded) {
            if (this.y - this.fallStartY &gt; MAX_FALL &amp;&amp; this.job !== &#039;BUFFER&#039;) {
                this.corrupt(game);
                return;
            }
            this.fallStartY = this.y;
            if ([&#039;BRUTE&#039;, &#039;DRILL&#039;, &#039;PATCH&#039;].includes(this.job)) this.assignJob(&#039;STREAM&#039;);
        }
    }
    
    compileCode(world) {
        const gx = world.toGrid(this.x + this.w/2);
        const gy = world.toGrid(this.y + this.h - 1);
        const tx = gx + this.dir;
        const ty = gy - 1; 
        if (world.get(tx, ty) !== T_NULL) return false;
        const block = this.dir &gt; 0 ? T_DATA : T_DATA;
        world.set(tx, gy, block); 
        this.x = (tx * TILE) + (this.dir &gt; 0 ? 0 : 2);
        this.y = (gy * TILE) - this.h - 0.1;
        this.vx = 0; this.vy = 0; this.remainderX = 0; this.remainderY = 0;
        return true;
    }

    triggerGlitch(game) {
        const cx = Math.floor((this.x + this.w/2)/TILE);
        const cy = Math.floor((this.y + this.h/2)/TILE);
        for(let y=cy-2; y&lt;=cy+2; y++) {
            for(let x=cx-2; x&lt;=cx+2; x++) {
                if (x&gt;0 &amp;&amp; x&lt;game.world.cols-1 &amp;&amp; y&gt;0 &amp;&amp; y&lt;game.world.rows-1) {
                    if (game.world.get(x,y) !== T_HARD) {
                        game.world.set(x,y, T_NULL);
                        if (Math.random() &gt; 0.5) game.spawnFragments(x*TILE, y*TILE, COL_BIT);
                    }
                }
            }
        }
        game.spawnFragments(this.x, this.y, COL_FIRE);
        this.destroy();
    }

    corrupt(game) {
        game.spawnFragments(this.x, this.y, COL_FIRE);
        this.destroy();
    }

    draw(gfx) {
        let c = this.job === &#039;STREAM&#039; ? COL_BIT : COL_BIT_ACTIVE;
        if (this.job === &#039;GLITCH&#039;) c = (this.jobTimer * 10) % 2 &gt; 1 ? COL_BIT : COL_FIRE;

        gfx.rect(this.x, this.y, this.w, this.h, c);
        const eyeX = this.dir &gt; 0 ? this.x + 4 : this.x;
        gfx.rect(eyeX, this.y+1, 2, 2, COL_BG);
        gfx.text(this.label, this.x + 1, this.y - 2, {size: 6, color: COL_CODE});
        
        if (this.job === &#039;BUFFER&#039;) gfx.rect(this.x-1, this.y-2, 8, 2, COL_BIT_ACTIVE); 
        if (this.job === &#039;MUTEX&#039;) gfx.rect(this.x, this.y, this.w, this.h, `rgba(255,145,0,0.3)`); 
        if (this.job === &#039;DRILL&#039;) gfx.rect(this.x+2, this.y+this.h, 2, 3, COL_BIT_ACTIVE); 
    }
}

class UploadPort extends Entity {
    constructor(x, y) {
        super(x, y);
        this.w = 24; this.h = 24;
        this.timer = 0;
    }
    update(dt, input, game) {
        this.timer += dt;
        const bits = game.collideAll(this, Bit);
        bits.forEach(b =&gt; {
            if (!b.dead) {
                game.saveBit();
                b.destroy();
            }
        });
    }
    draw(gfx) {
        const glow = Math.abs(Math.sin(this.timer * 4)) * 0.5;
        gfx.rect(this.x, this.y, this.w, this.h, `rgba(79, 195, 247, ${0.2 + glow})`);
        gfx.rect(this.x+8, this.y+8, 8, 8, COL_BIT);
        gfx.text(&#039;UPLOAD&#039;, this.x-2, this.y-5, {size: 6, color: COL_BIT});
    }
}

// =============================================================================
// GAME CONTROLLER
// =============================================================================

class DataStreamGame extends Game {

    static meta = {
        id: &quot;datastream&quot;, // Overwrites slot
        title: &quot;q-Bit Data Adventure&quot;,
        desc: &quot;Guide packets to the upload port.\nCollect Orange Packets for bonus units.&quot;,
        instructions: &quot;Tap tools to assign functions.\nDon&#039;t give up.&quot;
    };

    onInit() {
        this.score = 0;
        this.savedCount = 0;
        this.bonusBits = 0; 
        
        this.level = this.api.getData(&#039;level&#039;) || 1;
        const carryOver = this.api.getData(&#039;bonus_carry&#039;) || 0;
        this.totalBits = 20 + (this.level * 2) + carryOver;
        this.api.saveData(&#039;bonus_carry&#039;, 0);
        
        const gridH = this.api.H - UI_HEIGHT;
        const cols = Math.ceil(this.api.W / TILE);
        const rows = Math.ceil(gridH / TILE);
        this.world = new Physics.World(cols, rows, TILE);
        
        this.tools = [
            { id: &#039;STREAM&#039;, lbl: &#039;PING&#039;,   name: &#039;WALK&#039;,  cost: 0 },
            { id: &#039;BRUTE&#039;,  lbl: &#039;HACK&#039;,   name: &#039;BASH&#039;,  cost: 0 },
            { id: &#039;DRILL&#039;,  lbl: &#039;MINE&#039;,   name: &#039;DIG&#039;,   cost: 0 },
            { id: &#039;PATCH&#039;,  lbl: &#039;CODE&#039;,   name: &#039;BLD&#039;,   cost: 0 },
            { id: &#039;BUFFER&#039;, lbl: &#039;FLOAT&#039;,   name: &#039;FLOAT&#039;, cost: 0 },
            { id: &#039;MUTEX&#039;,  lbl: &#039;HALT&#039;,   name: &#039;HALT&#039;,  cost: 0 },
            { id: &#039;GLITCH&#039;, lbl: &#039;ERROR&#039;,   name: &#039;BOMB&#039;,  cost: 0 },
            { id: &#039;NUKE&#039;,   lbl: &#039;ABORT&#039;,   name: &#039;NUKE&#039;,  cost: 0 },
            { id: &#039;FF&#039;,     lbl: &#039;&gt;&gt;&#039;,  name: &#039;FAST&#039;,  cost: 0 }
        ];
        
        this.inventory = {};
        this.tools.forEach(t =&gt; this.inventory[t.id] = t.cost &gt; 0 ? 5 : Infinity);
        this.selectedTool = &#039;STREAM&#039;;
        this.isFastForward = false;

        this.genLevel(cols, rows);
        this.buildUI();
        
        this.spawnTimer = 0;
        this.bitsToSpawn = this.totalBits;
        
        this.api.setStatus(`SECTOR ${this.level}`);
        this.updateLabel();
    }

    genLevel(cols, rows) {
        // Fill
        for(let i=0; i&lt;this.world.data.length; i++) this.world.data[i] = Math.random() &lt; 0.4 ? T_DATA : T_NULL;
        
        // Smooth
        for(let k=0; k&lt;4; k++) {
            const next = new Uint8Array(this.world.data);
            for(let y=1; y&lt;rows-1; y++) {
                for(let x=1; x&lt;cols-1; x++) {
                    let n = 0;
                    for(let dy=-1; dy&lt;=1; dy++) for(let dx=-1; dx&lt;=1; dx++) if(this.world.get(x+dx, y+dy) !== T_NULL) n++;
                    if(n &gt; 4) next[y*cols+x] = T_DATA; else if(n &lt; 4) next[y*cols+x] = T_NULL;
                }
            }
            this.world.data = next;
        }
        
        // Borders
        for(let x=0; x&lt;cols; x++) { this.world.set(x, 0, T_HARD); this.world.set(x, rows-1, T_FIREWALL); }
        for(let y=0; y&lt;rows; y++) { this.world.set(0, y, T_HARD); this.world.set(cols-1, y, T_HARD); }

        // Spawn/Goal
        this.spawnX = 40; this.spawnY = 40;
        this.clearArea(5, 5, 6, 6);
        this.world.set(5, 8, T_HARD); this.world.set(6, 8, T_HARD);
        
        const goalCol = cols - 8; const goalRow = rows - 10;
        this.clearArea(goalCol, goalRow, 6, 6);
        this.world.set(goalCol, goalRow+3, T_HARD); this.world.set(goalCol+1, goalRow+3, T_HARD);
        this.add(new UploadPort(goalCol*TILE, goalRow*TILE));
        
        // Hazards &amp; Bonus
        for(let i=0; i&lt;8; i++) this.world.set(PC.randInt(10, cols-10), PC.randInt(10, rows-10), T_FIREWALL);
        
        const numPackets = PC.randInt(1, 3);
        for(let i=0; i&lt;numPackets; i++) {
            let placed = false;
            while(!placed) {
                const px = PC.randInt(10, cols-10); const py = PC.randInt(10, rows-10);
                if (this.world.get(px, py) === T_NULL &amp;&amp; this.world.get(px, py+1) !== T_NULL) {
                    this.world.set(px, py, T_PACKET); placed = true;
                }
            }
        }
    }
    
    clearArea(gx, gy, w, h) {
        for(let y=gy; y&lt;gy+h; y++) for(let x=gx; x&lt;gx+w; x++) this.world.set(x, y, T_NULL);
    }

    buildUI() {
        this.api.UI.build([
            { type: &#039;spacer&#039;, size: this.api.H - UI_HEIGHT + 2 },
            { 
                type: &#039;grid&#039;, cols: 9, gap: 1,
                children: this.tools.map(t =&gt; ({
                    type: &#039;button&#039;, id: `tool-${t.id}`, text: t.lbl,
                    style: {
                        fontSize: &#039;12px&#039;, height: &#039;32px&#039;, padding: &#039;0&#039;,
                        fontFamily: &#039;monospace&#039;, lineHeight: &#039;10px&#039;,
                        background: COL_BG, border: `1px solid ${COL_DATA}`, color: COL_CODE,
                        whiteSpace: &#039;pre&#039;
                    },
                    onClick: () =&gt; this.selectTool(t.id)
                }))
            }
        ]);
        this.refreshButtons();
    }
    
    selectTool(id) {
        if (id === &#039;NUKE&#039;) { this.bitsToSpawn = 0; this.entities.forEach(e =&gt; { if(e instanceof Bit) e.nukeTriggered = true; }); return; }
        if (id === &#039;FF&#039;) { this.isFastForward = !this.isFastForward; this.refreshButtons(); return; }
        this.selectedTool = id; this.refreshButtons();
    }
    
    refreshButtons() {
        this.tools.forEach(t =&gt; {
            const btn = this.api.UI.get(`tool-${t.id}`);
            if (!btn) return;
            const count = this.inventory[t.id];
            const display = count === Infinity ? &#039;∞&#039; : count;
            btn.textContent = `${t.lbl}\n${display}`;
            const active = (this.selectedTool === t.id) || (t.id === &#039;FF&#039; &amp;&amp; this.isFastForward);
            btn.style.borderColor = active ? COL_BIT_ACTIVE : COL_DATA;
            btn.style.color = active ? COL_BIT_ACTIVE : COL_CODE;
        });
    }

    update(dt, input) {
        const iterations = this.isFastForward ? 3 : 1;
        for(let i=0; i&lt;iterations; i++) {
            if (this.bitsToSpawn &gt; 0) {
                this.spawnTimer -= dt;
                if (this.spawnTimer &lt;= 0) {
                    this.add(new Bit(this.spawnX, this.spawnY));
                    this.bitsToSpawn--;
                    this.spawnTimer = 1.0;
                    this.updateLabel();
                }
            }
            if (i === 0 &amp;&amp; input.mouse.clicked &amp;&amp; input.mouse.y &lt; this.api.H - UI_HEIGHT) this.handleInput(input.mouse.x, input.mouse.y);
            super.update(dt, input);
            this.handleCollisions();
        }
        const activeBits = this.entities.filter(e =&gt; e instanceof Bit &amp;&amp; !e.dead).length;
        if (this.bitsToSpawn === 0 &amp;&amp; activeBits === 0) this.endLevel();
    }
    
    handleInput(mx, my) {
        for(let i=this.entities.length-1; i&gt;=0; i--) {
            const e = this.entities[i];
            if (e instanceof Bit &amp;&amp; !e.dead &amp;&amp; this.api.pointInEntity(mx, my, e, 6)) {
                if (this.selectedTool === &#039;STREAM&#039; &amp;&amp; e.job === &#039;STREAM&#039;) { e.assignJob(&#039;STREAM&#039;); return; }
                if (this.inventory[this.selectedTool] &gt; 0) {
                    e.assignJob(this.selectedTool);
                    if (this.inventory[this.selectedTool] !== Infinity) { this.inventory[this.selectedTool]--; this.refreshButtons(); }
                }
                return; 
            }
        }
    }
    
    handleCollisions() {
        const bits = this.entities.filter(e =&gt; e instanceof Bit &amp;&amp; !e.dead);
        const mutexes = bits.filter(e =&gt; e.job === &#039;MUTEX&#039;);
        if (mutexes.length === 0) return;
        for (const b of bits) {
            if (b.job === &#039;MUTEX&#039; || b.vx === 0) continue; 
            for (const m of mutexes) {
                if (b === m) continue;
                if (Math.abs(b.x - m.x) &lt; 6 &amp;&amp; Math.abs(b.y - m.y) &lt; 6) {
                    if (b.x &lt; m.x &amp;&amp; b.dir &gt; 0) { b.dir = -1; b.vx = b.dir * b.speed; }
                    if (b.x &gt; m.x &amp;&amp; b.dir &lt; 0) { b.dir = 1;  b.vx = b.dir * b.speed; }
                }
            }
        }
    }

    spawnFragments(x, y, color) { for(let i=0; i&lt;5; i++) this.add(new Fragment(x, y, color)); }
    saveBit() { this.savedCount++; this.score += 100; this.updateLabel(); }
    collectPacket() { this.bonusBits += 10; this.score += 500; this.updateLabel(); }
    updateLabel() { let txt = `QUEUE: ${this.bitsToSpawn} | SAVED: ${this.savedCount}`; if (this.bonusBits &gt; 0) txt += ` | BONUS: +${this.bonusBits}`; this.api.setLabel(txt); this.api.setScore(this.score); }
    
    endLevel() {
        if (this.savedCount &gt; 0) {
            this.api.saveData(&#039;level&#039;, this.level + 1);
            this.api.saveData(&#039;bonus_carry&#039;, this.bonusBits);
            this.api.newStage(&quot;DATA UPLOAD COMPLETE&quot;, `Packets Saved: ${this.savedCount}\nCollected Bonus: ${this.bonusBits}`, &quot;NEXT SECTOR&quot;, () =&gt; this.onInit());
        } else {
            this.api.gameOver(&quot;CONNECTION LOST\nZero packets survived.&quot;);
        }
    }

    draw(gfx) {
        gfx.clear(COL_BG);
        const ctx = gfx.ctx();
        for(let y=0; y&lt;this.world.rows; y++) {
            for(let x=0; x&lt;this.world.cols; x++) {
                const t = this.world.get(x,y);
                const px = x*TILE; const py = y*TILE;
                if (t === T_DATA) { gfx.rect(px, py, TILE, TILE, COL_DATA); gfx.text(Math.random()&gt;.5?&#039;1&#039;:&#039;0&#039;, px+1, py+6, {size:6, color: &#039;rgba(255,255,255,0.1)&#039;}); }
                else if (t === T_HARD) gfx.rect(px, py, TILE, TILE, COL_HARD);
                else if (t === T_FIREWALL) gfx.rect(px, py, TILE, TILE, Math.random()&gt;.8?COL_FIRE:&#039;#b03c00&#039;);
                else if (t === T_PACKET) { gfx.circle(px+4, py+4, 3, COL_PACKET); gfx.text(&#039;+&#039;, px+2, py+6, {size:6, color:&#039;#fff&#039;}); }
                else if (t === T_CODE_R) { ctx.fillStyle = COL_CODE; ctx.beginPath(); ctx.moveTo(px, py+TILE); ctx.lineTo(px+TILE, py+TILE); ctx.lineTo(px+TILE, py); ctx.fill(); }
                else if (t === T_CODE_L) { ctx.fillStyle = COL_CODE; ctx.beginPath(); ctx.moveTo(px, py); ctx.lineTo(px, py+TILE); ctx.lineTo(px+TILE, py+TILE); ctx.fill(); }
            }
        }
        gfx.rect(0, this.api.H - UI_HEIGHT, this.api.W, 1, COL_BIT_ACTIVE);
        super.draw(gfx);
    }
}

Interactive.register(DataStreamGame);</code></pre>
                      <p class="download-btn-container">
                        <a href="/Stealware/PodCube%20API/trash/datastream.js" class="page-download-btn" download>DOWNLOAD "datastream.js" ⤓</a>
                      </p>
                    </div>
  
  


                    
                    
                    
                    <div id="dir-sentinel" style="display: block; width: 100%; visibility: hidden; pointer-events: none;"></div>
                </main>
            
            
                
                
                
                
                
                    <section class="directory-container">
                        <div class="directory-header">
                            
                                <a href="/Stealware/PodCube API/" class="nav-link-small up">...</a><span class="nav-link-small up" style="color: var(--border-color)">\</span>
                            
                            
                            
                            <h3 class="directory-title">
                                trash
                            </h3>
                        </div>
                        
                        
                            <ul class="dir-listing">

                                


                                
                                
                                
                                    <li>
                                        <span class="icon" style="-webkit-mask-image: url('/.config/fileicon.svg'); mask-image: url('/.config/fileicon.svg');"></span>
                                        <a class="nowrap" href="/Stealware/PodCube API/trash/datastream.js.html">datastream.js</a>
                                        <a href="/Stealware/PodCube API/trash/datastream.js" download class="dir-download-icon" title="Download datastream.js"></a>
                                    </li>
                                
                                    <li>
                                        <span class="icon" style="-webkit-mask-image: url('/.config/fileicon.svg'); mask-image: url('/.config/fileicon.svg');"></span>
                                        <a class="nowrap" href="/Stealware/PodCube API/trash/interactive_gem.js.html">interactive_gem.js</a>
                                        <a href="/Stealware/PodCube API/trash/interactive_gem.js" download class="dir-download-icon" title="Download interactive_gem.js"></a>
                                    </li>
                                
                                    <li>
                                        <span class="icon" style="-webkit-mask-image: url('/.config/fileicon.svg'); mask-image: url('/.config/fileicon.svg');"></span>
                                        <a class="nowrap" href="/Stealware/PodCube API/trash/interactive_old.js.html">interactive_old.js</a>
                                        <a href="/Stealware/PodCube API/trash/interactive_old.js" download class="dir-download-icon" title="Download interactive_old.js"></a>
                                    </li>
                                
                                    <li>
                                        <span class="icon" style="-webkit-mask-image: url('/.config/fileicon.svg'); mask-image: url('/.config/fileicon.svg');"></span>
                                        <a class="nowrap" href="/Stealware/PodCube API/trash/lemmings.js.html">lemmings.js</a>
                                        <a href="/Stealware/PodCube API/trash/lemmings.js" download class="dir-download-icon" title="Download lemmings.js"></a>
                                    </li>
                                
                                    <li>
                                        <span class="icon" style="-webkit-mask-image: url('/.config/fileicon.svg'); mask-image: url('/.config/fileicon.svg');"></span>
                                        <a class="nowrap" href="/Stealware/PodCube API/trash/old_snake.js.html">old_snake.js</a>
                                        <a href="/Stealware/PodCube API/trash/old_snake.js" download class="dir-download-icon" title="Download old_snake.js"></a>
                                    </li>
                                
                                    <li>
                                        <span class="icon" style="-webkit-mask-image: url('/.config/fileicon.svg'); mask-image: url('/.config/fileicon.svg');"></span>
                                        <a class="nowrap" href="/Stealware/PodCube API/trash/quiz_old.js.html">quiz_old.js</a>
                                        <a href="/Stealware/PodCube API/trash/quiz_old.js" download class="dir-download-icon" title="Download quiz_old.js"></a>
                                    </li>
                                
                                    <li>
                                        <span class="icon" style="-webkit-mask-image: url('/.config/fileicon.svg'); mask-image: url('/.config/fileicon.svg');"></span>
                                        <a class="nowrap" href="/Stealware/PodCube API/trash/snake_old.js.html">snake_old.js</a>
                                        <a href="/Stealware/PodCube API/trash/snake_old.js" download class="dir-download-icon" title="Download snake_old.js"></a>
                                    </li>
                                
                                    <li>
                                        <span class="icon" style="-webkit-mask-image: url('/.config/fileicon.svg'); mask-image: url('/.config/fileicon.svg');"></span>
                                        <a class="nowrap" href="/Stealware/PodCube API/trash/systemrestore.js.html">systemrestore.js</a>
                                        <a href="/Stealware/PodCube API/trash/systemrestore.js" download class="dir-download-icon" title="Download systemrestore.js"></a>
                                    </li>
                                
                            </ul>
                        
                    </section>
                
            
            
        <script src="/js/main.js"></script>
    </body>
</body></html>